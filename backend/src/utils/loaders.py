from typing import Dict, List, Optional
import pandas as pd
import os
import json


def fix_encoding_text(text: Optional[str]) -> str:
    """
    Fixes encoding of a string using ISO-8859-1 (Latin-1) encoding
    :param text -- string to fix
    :return -- string with fixed encoding
    """
    if not text:
        return ""

    try:
        return text.encode("latin1").decode("utf-8")
    except (UnicodeDecodeError, UnicodeEncodeError, AttributeError):
        return text


def load_json_with_correct_encoding(file_path: str) -> dict:
    """
    Loads JSON file with proper encoding for Facebook exports
    :param file_path -- path to JSON file
    :return -- dict
    """
    with open(file_path, 'r', encoding='utf-8') as f:
        data = json.load(f)

    def fix_dict(obj):
        if isinstance(obj, dict):
            return {k: fix_dict(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [fix_dict(item) for item in obj]
        elif isinstance(obj, str):
            return fix_encoding_text(obj)
        else:
            return obj

    return fix_dict(data)


def load_message_data(path_to_data: str) -> pd.DataFrame:
    """
    Loads messages from JSON files generated by Facebook export tool
    :param path_to_data -- path to folder with JSON files
    :return -- DataFrame containing messages with corresponding dates and senders
    """
    if not os.path.exists(path_to_data):
        raise FileNotFoundError(f"Path {path_to_data} does not exist")

    dfs = []

    for file in os.listdir(path_to_data):
        if file.endswith(".json"):
            file_path = os.path.join(path_to_data, file)
            data = load_json_with_correct_encoding(file_path)

            messages_raw = data.get("messages", [])

            if messages_raw:
                dfs.append(process_message_data(messages_raw))

    if not dfs:
        return pd.DataFrame(columns=["send_datetime", "message", "sender_name"])

    return pd.concat(dfs, ignore_index=True)


def process_message_data(data: List[Dict]) -> pd.DataFrame:
    """
    Converts processed message data to a DataFrame
    :param data -- list of dicts containing message data
    :return -- DataFrame
    """
    df = pd.DataFrame(data)

    if "content" in df.columns:
        df["message"] = df["content"].fillna("").apply(fix_encoding_text)
    else:
        df["message"] = ""

    df["sender_name"] = df["sender_name"].fillna("").apply(fix_encoding_text)

    system_patterns = [
        "zadzwonił", "zadzwoniła",
        "odebrał", "odebrała",
        "zmienił", "zmieniła",
        "zareagował", "zareagowała",
        "ustawił", "ustawiła",
        "nieodebrane połączenie"
        "połączenie wideo",
        "motyw czatu"
    ]

    def is_real_text(row):
        msg = row["message"].strip()
        msg_type = row.get("type", "")

        if msg_type == "Call":
            return False

        if not msg:
            return False

        if any(key in row for key in ["photos", "videos", "files", "audio_files"]) and not msg:
            return False

        if any(pattern in msg for pattern in system_patterns):
            return False

        return True

    df["is_analyzable"] = df.apply(is_real_text, axis=1)

    df["send_datetime"] = pd.to_datetime(df["timestamp_ms"], unit="ms")

    return df[["send_datetime", "message", "sender_name", "is_analyzable"]]
